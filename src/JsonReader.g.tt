<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
// Copyright (c) 2021 Atif Aziz.
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

//------------------------------------------------------------------------------
// This code was generated by a tool.
// Changes to this file will be lost if the code is re-generated.
//------------------------------------------------------------------------------

namespace Jacob;

using System;
using System.Text.Json;

partial class JsonReader
{<#
{
    foreach (var e in new[]
    {
        new { Native = "byte"  , Api = "Byte"   },
        new { Native = "int"   , Api = "Int32"  },
        new { Native = "long"  , Api = "Int64"  },
        new { Native = "ushort", Api = "UInt16" },
        new { Native = "uint"  , Api = "UInt32" },
        new { Native = "ulong" , Api = "UInt64" },
        new { Native = "double", Api = "Double" },
        new { Native = "float" , Api = "Single" },
    })
    { #>

    static IJsonReader<<#= e.Native #>> <#= e.Native #>Reader;

    public static IJsonReader<<#= e.Native #>> <#= e.Api #>() =>
        <#= e.Native #>Reader ??=
            Create(static (ref Utf8JsonReader rdr) =>
                rdr.TokenType is JsonTokenType.Number && rdr.TryGet<#= e.Api #>(out var value)
                ? Value(value)
                : Error("Invalid JSON value; expecting a JSON number compatible with <#= e.Api #>."));
<#
    }
}

{
    const int maxArity = 16;

    var all = Enumerable.Range(1, maxArity)
                        .Select(n => n.ToString(CultureInfo.InvariantCulture))
                        .ToArray();

    for (var c = 2; c < maxArity; c++)
    {
        var ns = all.Take(c);
        var ts = string.Join(", ", from n in ns select "T" + n);
        var vs = string.Join(", ", from n in ns select "v" + n);
#>

    /// <remarks>
    /// Properties without a default value that are missing from the read JSON object will cause
    /// the reader to return an error result.
    /// </remarks>
    public static IJsonReader<TResult> Object<<#= ts #>, TResult>(
            <#= string.Join(", ", from n in ns select "IJsonProperty<T" + n + "> property" + n) #>,
            Func<<#= ts #>, TResult> projector) =>
        Object(<#= string.Join(", ", from n in ns select "property" + n) #>,
               <#= string.Join(", ", Enumerable.Repeat("NonProperty.Instance", maxArity - c)) #>,
               (<#= vs #>, <#= string.Join(", ", Enumerable.Repeat("_", maxArity - c)) #>) =>
            projector(<#= vs #>));
<#  }
}

{
    const int maxArity = 3;

    var all = Enumerable.Range(1, maxArity)
                        .Select(n => n.ToString(CultureInfo.InvariantCulture))
                        .ToArray();

    for (var c = 2; c <= maxArity; c++)
    {
        var ns = all.Take(c);
        var ts = string.Join(", ", from n in ns select "T" + n);
        var vs = string.Join(", ", from n in ns select "v" + n);
#>

    public static IJsonReader<(<#= ts #>)>
        Tuple<<#= ts #>>(
            <#= string.Join(@",
            ", from n in ns select "IJsonReader<T" + n + "> item" + n + "Reader") #>) =>
        CreatePure((ref Utf8JsonReader rdr) =>
        {
            if (rdr.TokenType is JsonTokenType.None && !rdr.Read())
                throw PartialJsonNotSupportedException();

            if (rdr.TokenType is not JsonTokenType.StartArray)
                return Error("Invalid JSON value where a JSON array was expected.");
<#
        foreach (var n in ns)
        { #>

            if (!rdr.Read())
                throw PartialJsonNotSupportedException();

            T<#= n #> item<#= n #>;
            switch(item<#= n #>Reader.TryRead(ref rdr))
            {
                case { Incomplete: true }: throw PartialJsonNotSupportedException();
                case { Error: { } error<#= n #> }: return Error(error<#= n #>);
                case { Value: var item }: item<#= n #> = item; break;
            }
<#
        } #>

            if (!rdr.Read())
                throw PartialJsonNotSupportedException();

            if (rdr.TokenType is not JsonTokenType.EndArray)
                return Error("Invalid JSON value; JSON array has too many values.");

            return Value((<#= string.Join(", ", from n in ns select "item" + n) #>));
        });
<#  }
} #>
}
